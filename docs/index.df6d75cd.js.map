{"mappings":"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","sources":["<anon>","src/saveSvgAsPng.js"],"sourcesContent":["(function() {\n    var out$ = typeof exports != 'undefined' && exports || typeof define != 'undefined' && {} || this;\n    var doctype = '<?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [<!ENTITY nbsp \"&#160;\">]>';\n    function isElement(obj) {\n        return obj instanceof HTMLElement || obj instanceof SVGElement;\n    }\n    function requireDomNode(el) {\n        if (!isElement(el)) throw new Error('an HTMLElement or SVGElement is required; got ' + el);\n    }\n    function isExternal(url) {\n        return url && url.lastIndexOf('http', 0) == 0 && url.lastIndexOf(window.location.host) == -1;\n    }\n    function inlineImages(el, callback) {\n        requireDomNode(el);\n        var images = el.querySelectorAll('image'), left = images.length, checkDone = function() {\n            if (left === 0) callback();\n        };\n        checkDone();\n        for(var i = 0; i < images.length; i++)(function(image) {\n            var href = image.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\");\n            if (href) {\n                if (isExternal(href.value)) {\n                    console.warn(\"Cannot render embedded images linking to external hosts: \" + href.value);\n                    return;\n                }\n            }\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            ctx.imageSmoothingEnabled = false;\n            var img = new Image();\n            img.crossOrigin = \"anonymous\";\n            href = href || image.getAttribute('href');\n            if (href) {\n                img.src = href;\n                img.onload = function() {\n                    canvas.width = img.width;\n                    canvas.height = img.height;\n                    ctx.drawImage(img, 0, 0);\n                    image.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", canvas.toDataURL('image/png'));\n                    left--;\n                    checkDone();\n                };\n                img.onerror = function() {\n                    console.log(\"Could not load \" + href);\n                    left--;\n                    checkDone();\n                };\n            } else {\n                left--;\n                checkDone();\n            }\n        })(images[i]);\n    }\n    function styles(el, options, cssLoadedCallback) {\n        var selectorRemap = options.selectorRemap;\n        var modifyStyle = options.modifyStyle;\n        var css = \"\";\n        // each font that has extranl link is saved into queue, and processed\n        // asynchronously\n        var fontsQueue = [];\n        var sheets = document.styleSheets;\n        for(var i = 0; i < sheets.length; i++){\n            try {\n                var rules = sheets[i].cssRules;\n                console.log(\"Stylesheet loaded: \" + sheets[i].href);\n            } catch (e) {\n                console.warn(\"Stylesheet could not be loaded: \" + sheets[i].href);\n                continue;\n            }\n            if (rules != null) for(var j = 0, match; j < rules.length; j++, match = null){\n                var rule = rules[j];\n                if (typeof rule.style != \"undefined\") {\n                    var selectorText;\n                    try {\n                        selectorText = rule.selectorText;\n                    } catch (err) {\n                        console.warn('The following CSS rule has an invalid selector: \"' + rule + '\"', err);\n                    }\n                    try {\n                        if (selectorText) match = el.querySelector(selectorText) || el.parentNode.querySelector(selectorText);\n                    } catch (err) {\n                        console.warn('Invalid CSS selector \"' + selectorText + '\"', err);\n                    }\n                    if (match) {\n                        var selector = selectorRemap ? selectorRemap(rule.selectorText) : rule.selectorText;\n                        var cssText = modifyStyle ? modifyStyle(rule.style.cssText) : rule.style.cssText;\n                        css += selector + \" { \" + cssText + \" }\\n\";\n                    } else if (rule.cssText.match(/^@font-face/)) css += rule.cssText + '\\n';\n                }\n            }\n        }\n        // Now all css is processed, it's time to handle scheduled fonts\n        // processFontQueue(fontsQueue);\n        cssLoadedCallback(css);\n        function getFontMimeTypeFromUrl(fontUrl) {\n            var supportedFormats = {\n                'woff2': 'font/woff2',\n                'woff': 'font/woff',\n                'otf': 'application/x-font-opentype',\n                'ttf': 'application/x-font-ttf',\n                'eot': 'application/vnd.ms-fontobject',\n                'sfnt': 'application/font-sfnt',\n                'svg': 'image/svg+xml'\n            };\n            var extensions = Object.keys(supportedFormats);\n            for(var i = 0; i < extensions.length; ++i){\n                var extension = extensions[i];\n                // TODO: This is not bullet proof, it needs to handle edge cases...\n                if (fontUrl.indexOf('.' + extension) > 0) return supportedFormats[extension];\n            }\n            // If you see this error message, you probably need to update code above.\n            console.error('Unknown font format for ' + fontUrl + '; Fonts may not be working correctly');\n            return 'application/octet-stream';\n        }\n        function processFontQueue(queue) {\n            if (queue.length > 0) {\n                // load fonts one by one until we have anything in the queue:\n                var font = queue.pop();\n                processNext(font);\n            } else // no more fonts to load.\n            cssLoadedCallback(css);\n            function processNext(font) {\n                // TODO: This could benefit from caching.\n                var oReq = new XMLHttpRequest();\n                oReq.addEventListener('load', fontLoaded);\n                oReq.addEventListener('error', transferFailed);\n                oReq.addEventListener('abort', transferFailed);\n                oReq.open('GET', font.url);\n                oReq.responseType = 'arraybuffer';\n                oReq.send();\n                function fontLoaded() {\n                    // TODO: it may be also worth to wait until fonts are fully loaded before\n                    // attempting to rasterize them. (e.g. use https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet )\n                    var fontBits = oReq.response;\n                    var fontInBase64 = arrayBufferToBase64(fontBits);\n                    updateFontStyle(font, fontInBase64);\n                }\n                function transferFailed(e) {\n                    console.warn('Failed to load font from: ' + font.url);\n                    console.warn(e);\n                    css += font.text + '\\n';\n                    processFontQueue(queue);\n                }\n                function updateFontStyle(font, fontInBase64) {\n                    var dataUrl = 'url(\"data:' + font.format + ';base64,' + fontInBase64 + '\")';\n                    css += font.text.replace(font.fontUrlRegexp, dataUrl) + '\\n';\n                    // schedule next font download on next tick.\n                    setTimeout(function() {\n                        processFontQueue(queue);\n                    }, 0);\n                }\n            }\n        }\n        function arrayBufferToBase64(buffer) {\n            var binary = '';\n            var bytes = new Uint8Array(buffer);\n            var len = bytes.byteLength;\n            for(var i = 0; i < len; i++)binary += String.fromCharCode(bytes[i]);\n            return window.btoa(binary);\n        }\n    }\n    function getDimension(el, clone, dim) {\n        var v = el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim] || clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim)) || el.getBoundingClientRect()[dim] || parseInt(clone.style[dim]) || parseInt(window.getComputedStyle(el).getPropertyValue(dim));\n        return typeof v === 'undefined' || v === null || isNaN(parseFloat(v)) ? 0 : v;\n    }\n    function reEncode(data) {\n        data = encodeURIComponent(data);\n        data = data.replace(/%([0-9A-F]{2})/g, function(match, p1) {\n            var c = String.fromCharCode('0x' + p1);\n            return c === '%' ? '%25' : c;\n        });\n        return decodeURIComponent(data);\n    }\n    out$.prepareSvg = function(el, options, cb) {\n        requireDomNode(el);\n        options = options || {};\n        options.scale = options.scale || 1;\n        options.responsive = options.responsive || false;\n        var xmlns = \"http://www.w3.org/2000/xmlns/\";\n        inlineImages(el, function() {\n            var outer = document.createElement(\"div\");\n            var clone = el.cloneNode(true);\n            var width, height;\n            if (el.tagName == 'svg') {\n                width = options.width || getDimension(el, clone, 'width');\n                height = options.height || getDimension(el, clone, 'height');\n            } else if (el.getBBox) {\n                var box = el.getBBox();\n                width = box.x + box.width;\n                height = box.y + box.height;\n                clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\\(.*?\\)/, ''));\n                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                svg.appendChild(clone);\n                clone = svg;\n            } else {\n                console.error('Attempted to render non-SVG element', el);\n                return;\n            }\n            clone.setAttribute(\"version\", \"1.1\");\n            if (!clone.getAttribute('xmlns')) clone.setAttributeNS(xmlns, \"xmlns\", \"http://www.w3.org/2000/svg\");\n            if (!clone.getAttribute('xmlns:xlink')) clone.setAttributeNS(xmlns, \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n            if (options.responsive) {\n                clone.removeAttribute('width');\n                clone.removeAttribute('height');\n                clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n            } else {\n                clone.setAttribute(\"width\", width * options.scale);\n                clone.setAttribute(\"height\", height * options.scale);\n            }\n            clone.setAttribute(\"viewBox\", [\n                options.left || 0,\n                options.top || 0,\n                width,\n                height\n            ].join(\" \"));\n            var fos = clone.querySelectorAll('foreignObject > *');\n            for(var i = 0; i < fos.length; i++)if (!fos[i].getAttribute('xmlns')) fos[i].setAttributeNS(xmlns, \"xmlns\", \"http://www.w3.org/1999/xhtml\");\n            outer.appendChild(clone);\n            // In case of custom fonts we need to fetch font first, and then inline\n            // its url into data-uri format (encode as base64). That's why style\n            // processing is done asynchonously. Once all inlining is finshed\n            // cssLoadedCallback() is called.\n            styles(el, options, cssLoadedCallback);\n            function cssLoadedCallback(css) {\n                // here all fonts are inlined, so that we can render them properly.\n                var s = document.createElement('style');\n                s.setAttribute('type', 'text/css');\n                s.innerHTML = \"<![CDATA[\\n\" + css + \"\\n]]>\";\n                var defs = document.createElement('defs');\n                defs.appendChild(s);\n                clone.insertBefore(defs, clone.firstChild);\n                if (cb) {\n                    var outHtml = outer.innerHTML;\n                    outHtml = outHtml.replace(/NS\\d+:href/gi, 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href');\n                    cb(outHtml, width, height);\n                }\n            }\n        });\n    };\n    out$.svgAsDataUri = function(el, options, cb) {\n        out$.prepareSvg(el, options, function(svg) {\n            var uri = 'data:image/svg+xml;base64,' + window.btoa(reEncode(doctype + svg));\n            if (cb) cb(uri);\n        });\n    };\n    out$.svgAsPngUri = function(el, options, cb) {\n        requireDomNode(el);\n        options = options || {};\n        options.encoderType = options.encoderType || 'image/png';\n        options.encoderOptions = options.encoderOptions || 0.8;\n        var convertToPng = function(src, w, h) {\n            var canvas = document.createElement('canvas');\n            var context = canvas.getContext('2d');\n            context.imageSmoothingEnabled = false;\n            canvas.width = w;\n            canvas.height = h;\n            if (options.canvg) options.canvg(canvas, src);\n            else context.drawImage(src, 0, 0);\n            if (options.backgroundColor) {\n                context.globalCompositeOperation = 'destination-over';\n                context.fillStyle = options.backgroundColor;\n                context.fillRect(0, 0, canvas.width, canvas.height);\n            }\n            var png;\n            try {\n                png = canvas.toDataURL(options.encoderType, options.encoderOptions);\n            } catch (e) {\n                if (typeof SecurityError !== 'undefined' && e instanceof SecurityError || e.name == \"SecurityError\") {\n                    console.error(\"Rendered SVG images cannot be downloaded in this browser.\");\n                    return;\n                } else throw e;\n            }\n            cb(png);\n        };\n        if (options.canvg) out$.prepareSvg(el, options, convertToPng);\n        else out$.svgAsDataUri(el, options, function(uri) {\n            var image = new Image();\n            image.onload = function() {\n                convertToPng(image, image.width, image.height);\n            };\n            image.onerror = function() {\n                console.error('There was an error loading the data URI as an image on the following SVG\\n', window.atob(uri.slice(26)), '\\n', \"Open the following link to see browser's diagnosis\\n\", uri);\n            };\n            image.src = uri;\n        });\n    };\n    out$.download = function(name, uri) {\n        if (navigator.msSaveOrOpenBlob) navigator.msSaveOrOpenBlob(uriToBlob(uri), name);\n        else {\n            var saveLink = document.createElement('a');\n            var downloadSupported = 'download' in saveLink;\n            if (downloadSupported) {\n                saveLink.download = name;\n                saveLink.style.display = 'none';\n                document.body.appendChild(saveLink);\n                try {\n                    var blob = uriToBlob(uri);\n                    var url = URL.createObjectURL(blob);\n                    saveLink.href = url;\n                    saveLink.onclick = function() {\n                        requestAnimationFrame(function() {\n                            URL.revokeObjectURL(url);\n                        });\n                    };\n                } catch (e) {\n                    console.warn('This browser does not support object URLs. Falling back to string URL.');\n                    saveLink.href = uri;\n                }\n                saveLink.click();\n                document.body.removeChild(saveLink);\n            } else window.open(uri, '_temp', 'menubar=no,toolbar=no,status=no');\n        }\n    };\n    function uriToBlob(uri) {\n        var byteString = window.atob(uri.split(',')[1]);\n        var mimeString = uri.split(',')[0].split(':')[1].split(';')[0];\n        var buffer = new ArrayBuffer(byteString.length);\n        var intArray = new Uint8Array(buffer);\n        for(var i = 0; i < byteString.length; i++)intArray[i] = byteString.charCodeAt(i);\n        return new Blob([\n            buffer\n        ], {\n            type: mimeString\n        });\n    }\n    out$.saveSvg = function(el, name, options) {\n        requireDomNode(el);\n        options = options || {};\n        out$.svgAsDataUri(el, options, function(uri) {\n            out$.download(name, uri);\n        });\n    };\n    out$.saveSvgAsPng = function(el, name, options) {\n        requireDomNode(el);\n        options = options || {};\n        out$.svgAsPngUri(el, options, function(uri) {\n            out$.download(name, uri);\n        });\n    };\n    // if define is defined create as an AMD module\n    if (typeof define !== 'undefined') define(function() {\n        return out$;\n    });\n})();\n\n//# sourceMappingURL=index.df6d75cd.js.map\n","(function() {\n  var out$ = typeof exports != 'undefined' && exports || typeof define != 'undefined' && {} || this;\n\n  var doctype = '<?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [<!ENTITY nbsp \"&#160;\">]>';\n\n  function isElement(obj) {\n    return obj instanceof HTMLElement || obj instanceof SVGElement;\n  }\n\n  function requireDomNode(el) {\n    if (!isElement(el)) {\n      throw new Error('an HTMLElement or SVGElement is required; got ' + el);\n    }\n  }\n\n  function isExternal(url) {\n    return url && url.lastIndexOf('http',0) == 0 && url.lastIndexOf(window.location.host) == -1;\n  }\n\n  function inlineImages(el, callback) {\n    requireDomNode(el);\n\n    var images = el.querySelectorAll('image'),\n        left = images.length,\n        checkDone = function() {\n          if (left === 0) {\n            callback();\n          }\n        };\n\n    checkDone();\n    for (var i = 0; i < images.length; i++) {\n      (function(image) {\n        var href = image.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\");\n        if (href) {\n          if (isExternal(href.value)) {\n            console.warn(\"Cannot render embedded images linking to external hosts: \"+href.value);\n            return;\n          }\n        }\n        var canvas = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        ctx.imageSmoothingEnabled = false;\n        var img = new Image();\n        img.crossOrigin=\"anonymous\";\n        href = href || image.getAttribute('href');\n        if (href) {\n          img.src = href;\n          img.onload = function() {\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0);\n            image.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", canvas.toDataURL('image/png'));\n            left--;\n            checkDone();\n          }\n          img.onerror = function() {\n            console.log(\"Could not load \"+href);\n            left--;\n            checkDone();\n          }\n        } else {\n          left--;\n          checkDone();\n        }\n      })(images[i]);\n    }\n  }\n\n  function styles(el, options, cssLoadedCallback) {\n    var selectorRemap = options.selectorRemap;\n    var modifyStyle = options.modifyStyle;\n    var css = \"\";\n    // each font that has extranl link is saved into queue, and processed\n    // asynchronously\n    var fontsQueue = [];\n    var sheets = document.styleSheets;\n    for (var i = 0; i < sheets.length; i++) {\n      try {\n        var rules = sheets[i].cssRules;\n        console.log(\"Stylesheet loaded: \"+sheets[i].href);\n      } catch (e) {\n        console.warn(\"Stylesheet could not be loaded: \"+sheets[i].href);\n        continue;\n      }\n\n      if (rules != null) {\n        for (var j = 0, match; j < rules.length; j++, match = null) {\n          var rule = rules[j];\n          if (typeof(rule.style) != \"undefined\") {\n            var selectorText;\n\n            try {\n              selectorText = rule.selectorText;\n            } catch(err) {\n              console.warn('The following CSS rule has an invalid selector: \"' + rule + '\"', err);\n            }\n\n            try {\n              if (selectorText) {\n                match = el.querySelector(selectorText) || el.parentNode.querySelector(selectorText);\n              }\n            } catch(err) {\n              console.warn('Invalid CSS selector \"' + selectorText + '\"', err);\n            }\n\n            if (match) {\n              var selector = selectorRemap ? selectorRemap(rule.selectorText) : rule.selectorText;\n              var cssText = modifyStyle ? modifyStyle(rule.style.cssText) : rule.style.cssText;\n              css += selector + \" { \" + cssText + \" }\\n\";\n            }\n              else if(rule.cssText.match(/^@font-face/)) {\n            css += rule.cssText + '\\n';\n            }\n          }\n        }\n      }\n    }\n\n    // Now all css is processed, it's time to handle scheduled fonts\n    // processFontQueue(fontsQueue);\n\n      cssLoadedCallback(css);\n\n    function getFontMimeTypeFromUrl(fontUrl) {\n      var supportedFormats = {\n        'woff2': 'font/woff2',\n        'woff': 'font/woff',\n        'otf': 'application/x-font-opentype',\n        'ttf': 'application/x-font-ttf',\n        'eot': 'application/vnd.ms-fontobject',\n        'sfnt': 'application/font-sfnt',\n        'svg': 'image/svg+xml'\n      };\n      var extensions = Object.keys(supportedFormats);\n      for (var i = 0; i < extensions.length; ++i) {\n        var extension = extensions[i];\n        // TODO: This is not bullet proof, it needs to handle edge cases...\n        if (fontUrl.indexOf('.' + extension) > 0) {\n          return supportedFormats[extension];\n        }\n      }\n\n      // If you see this error message, you probably need to update code above.\n      console.error('Unknown font format for ' + fontUrl+ '; Fonts may not be working correctly');\n      return 'application/octet-stream';\n    }\n\n    function processFontQueue(queue) {\n      if (queue.length > 0) {\n        // load fonts one by one until we have anything in the queue:\n        var font = queue.pop();\n        processNext(font);\n      } else {\n        // no more fonts to load.\n        cssLoadedCallback(css);\n      }\n\n      function processNext(font) {\n        // TODO: This could benefit from caching.\n        var oReq = new XMLHttpRequest();\n        oReq.addEventListener('load', fontLoaded);\n        oReq.addEventListener('error', transferFailed);\n        oReq.addEventListener('abort', transferFailed);\n        oReq.open('GET', font.url);\n        oReq.responseType = 'arraybuffer';\n        oReq.send();\n\n        function fontLoaded() {\n          // TODO: it may be also worth to wait until fonts are fully loaded before\n          // attempting to rasterize them. (e.g. use https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet )\n          var fontBits = oReq.response;\n          var fontInBase64 = arrayBufferToBase64(fontBits);\n          updateFontStyle(font, fontInBase64);\n        }\n\n        function transferFailed(e) {\n          console.warn('Failed to load font from: ' + font.url);\n          console.warn(e)\n          css += font.text + '\\n';\n          processFontQueue(queue);\n        }\n\n        function updateFontStyle(font, fontInBase64) {\n          var dataUrl = 'url(\"data:' + font.format + ';base64,' + fontInBase64 + '\")';\n          css += font.text.replace(font.fontUrlRegexp, dataUrl) + '\\n';\n\n          // schedule next font download on next tick.\n          setTimeout(function() {\n            processFontQueue(queue)\n          }, 0);\n        }\n\n      }\n    }\n\n    function arrayBufferToBase64(buffer) {\n      var binary = '';\n      var bytes = new Uint8Array(buffer);\n      var len = bytes.byteLength;\n\n      for (var i = 0; i < len; i++) {\n          binary += String.fromCharCode(bytes[i]);\n      }\n\n      return window.btoa(binary);\n    }\n  }\n\n  function getDimension(el, clone, dim) {\n    var v = (el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim]) ||\n      (clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim))) ||\n      el.getBoundingClientRect()[dim] ||\n      parseInt(clone.style[dim]) ||\n      parseInt(window.getComputedStyle(el).getPropertyValue(dim));\n    return (typeof v === 'undefined' || v === null || isNaN(parseFloat(v))) ? 0 : v;\n  }\n\n  function reEncode(data) {\n    data = encodeURIComponent(data);\n    data = data.replace(/%([0-9A-F]{2})/g, function(match, p1) {\n      var c = String.fromCharCode('0x'+p1);\n      return c === '%' ? '%25' : c;\n    });\n    return decodeURIComponent(data);\n  }\n\n  out$.prepareSvg = function(el, options, cb) {\n    requireDomNode(el);\n\n    options = options || {};\n    options.scale = options.scale || 1;\n    options.responsive = options.responsive || false;\n    var xmlns = \"http://www.w3.org/2000/xmlns/\";\n\n    inlineImages(el, function() {\n      var outer = document.createElement(\"div\");\n      var clone = el.cloneNode(true);\n      var width, height;\n      if(el.tagName == 'svg') {\n        width = options.width || getDimension(el, clone, 'width');\n        height = options.height || getDimension(el, clone, 'height');\n      } else if(el.getBBox) {\n        var box = el.getBBox();\n        width = box.x + box.width;\n        height = box.y + box.height;\n        clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\\(.*?\\)/, ''));\n\n        var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')\n        svg.appendChild(clone)\n        clone = svg;\n      } else {\n        console.error('Attempted to render non-SVG element', el);\n        return;\n      }\n\n      clone.setAttribute(\"version\", \"1.1\");\n      if (!clone.getAttribute('xmlns')) {\n        clone.setAttributeNS(xmlns, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      }\n      if (!clone.getAttribute('xmlns:xlink')) {\n        clone.setAttributeNS(xmlns, \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n      }\n\n      if (options.responsive) {\n        clone.removeAttribute('width');\n        clone.removeAttribute('height');\n        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n      } else {\n        clone.setAttribute(\"width\", width * options.scale);\n        clone.setAttribute(\"height\", height * options.scale);\n      }\n\n      clone.setAttribute(\"viewBox\", [\n        options.left || 0,\n        options.top || 0,\n        width,\n        height\n      ].join(\" \"));\n\n      var fos = clone.querySelectorAll('foreignObject > *');\n      for (var i = 0; i < fos.length; i++) {\n        if (!fos[i].getAttribute('xmlns')) {\n          fos[i].setAttributeNS(xmlns, \"xmlns\", \"http://www.w3.org/1999/xhtml\");\n        }\n      }\n\n      outer.appendChild(clone);\n\n      // In case of custom fonts we need to fetch font first, and then inline\n      // its url into data-uri format (encode as base64). That's why style\n      // processing is done asynchonously. Once all inlining is finshed\n      // cssLoadedCallback() is called.\n      styles(el, options, cssLoadedCallback);\n\n      function cssLoadedCallback(css) {\n        // here all fonts are inlined, so that we can render them properly.\n        var s = document.createElement('style');\n        s.setAttribute('type', 'text/css');\n        s.innerHTML = \"<![CDATA[\\n\" + css + \"\\n]]>\";\n        var defs = document.createElement('defs');\n        defs.appendChild(s);\n        clone.insertBefore(defs, clone.firstChild);\n\n        if (cb) {\n          var outHtml = outer.innerHTML;\n          outHtml = outHtml.replace(/NS\\d+:href/gi, 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href');\n          cb(outHtml, width, height);\n        }\n      }\n    });\n  }\n\n  out$.svgAsDataUri = function(el, options, cb) {\n    out$.prepareSvg(el, options, function(svg) {\n      var uri = 'data:image/svg+xml;base64,' + window.btoa(reEncode(doctype + svg));\n      if (cb) {\n        cb(uri);\n      }\n    });\n  }\n\n  out$.svgAsPngUri = function(el, options, cb) {\n    requireDomNode(el);\n\n    options = options || {};\n    options.encoderType = options.encoderType || 'image/png';\n    options.encoderOptions = options.encoderOptions || 0.8;\n\n    var convertToPng = function(src, w, h) {\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      context.imageSmoothingEnabled = false;\n      canvas.width = w;\n      canvas.height = h;\n\n      if(options.canvg) {\n        options.canvg(canvas, src);\n      } else {\n        context.drawImage(src, 0, 0);\n      }\n\n      if(options.backgroundColor){\n        context.globalCompositeOperation = 'destination-over';\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n      }\n\n      var png;\n      try {\n        png = canvas.toDataURL(options.encoderType, options.encoderOptions);\n      } catch (e) {\n        if ((typeof SecurityError !== 'undefined' && e instanceof SecurityError) || e.name == \"SecurityError\") {\n          console.error(\"Rendered SVG images cannot be downloaded in this browser.\");\n          return;\n        } else {\n          throw e;\n        }\n      }\n      cb(png);\n    }\n\n    if(options.canvg) {\n      out$.prepareSvg(el, options, convertToPng);\n    } else {\n      out$.svgAsDataUri(el, options, function(uri) {\n        var image = new Image();\n\n        image.onload = function() {\n          convertToPng(image, image.width, image.height);\n        }\n\n        image.onerror = function() {\n          console.error(\n            'There was an error loading the data URI as an image on the following SVG\\n',\n            window.atob(uri.slice(26)), '\\n',\n            \"Open the following link to see browser's diagnosis\\n\",\n            uri);\n        }\n\n        image.src = uri;\n      });\n    }\n  }\n\n  out$.download = function(name, uri) {\n    if (navigator.msSaveOrOpenBlob) {\n      navigator.msSaveOrOpenBlob(uriToBlob(uri), name);\n    } else {\n      var saveLink = document.createElement('a');\n      var downloadSupported = 'download' in saveLink;\n      if (downloadSupported) {\n        saveLink.download = name;\n        saveLink.style.display = 'none';\n        document.body.appendChild(saveLink);\n        try {\n          var blob = uriToBlob(uri);\n          var url = URL.createObjectURL(blob);\n          saveLink.href = url;\n          saveLink.onclick = function() {\n            requestAnimationFrame(function() {\n              URL.revokeObjectURL(url);\n            })\n          };\n        } catch (e) {\n          console.warn('This browser does not support object URLs. Falling back to string URL.');\n          saveLink.href = uri;\n        }\n        saveLink.click();\n        document.body.removeChild(saveLink);\n      }\n      else {\n        window.open(uri, '_temp', 'menubar=no,toolbar=no,status=no');\n      }\n    }\n  }\n\n  function uriToBlob(uri) {\n    var byteString = window.atob(uri.split(',')[1]);\n    var mimeString = uri.split(',')[0].split(':')[1].split(';')[0]\n    var buffer = new ArrayBuffer(byteString.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < byteString.length; i++) {\n      intArray[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([buffer], {type: mimeString});\n  }\n\n  out$.saveSvg = function(el, name, options) {\n    requireDomNode(el);\n\n    options = options || {};\n    out$.svgAsDataUri(el, options, function(uri) {\n      out$.download(name, uri);\n    });\n  }\n\n  out$.saveSvgAsPng = function(el, name, options) {\n    requireDomNode(el);\n\n    options = options || {};\n    out$.svgAsPngUri(el, options, function(uri) {\n      out$.download(name, uri);\n    });\n  }\n\n  // if define is defined create as an AMD module\n  if (typeof define !== 'undefined') {\n    define(function() {\n      return out$;\n    });\n  }\n\n})();\n"],"names":["out$","exports","define","requireDomNode","el","obj","HTMLElement","SVGElement","Error","getDimension","clone","dim","v","viewBox","baseVal","getAttribute","match","parseInt","getBoundingClientRect","style","window","getComputedStyle","getPropertyValue","isNaN","parseFloat","uriToBlob","uri","byteString","atob","split","mimeString","buffer","ArrayBuffer","length","intArray","Uint8Array","i","charCodeAt","Blob","type","prepareSvg","options","cb","scale","responsive","xmlns","inlineImages","callback","images","querySelectorAll","left","checkDone","image","url","href","getAttributeNS","value","lastIndexOf","location","host","console","warn","canvas","document","createElement","ctx","getContext","imageSmoothingEnabled","img","Image","crossOrigin","src","onload","width","height","drawImage","setAttributeNS","toDataURL","onerror","log","outer","cloneNode","tagName","getBBox","box","x","y","setAttribute","replace","svg","createElementNS","appendChild","error","removeAttribute","top","join","fos","styles","cssLoadedCallback","selectorRemap","modifyStyle","css","sheets","styleSheets","rules","cssRules","e","j","selectorText","rule","err","querySelector","parentNode","selector","cssText","s","innerHTML","defs","insertBefore","firstChild","outHtml","svgAsDataUri","btoa","decodeURIComponent","data","encodeURIComponent","doctype","p1","c","String","fromCharCode","svgAsPngUri","encoderType","encoderOptions","convertToPng","w","h","png","context","canvg","backgroundColor","globalCompositeOperation","fillStyle","fillRect","SecurityError","name","slice","download","navigator","msSaveOrOpenBlob","saveLink","display","body","blob","URL","createObjectURL","onclick","requestAnimationFrame","revokeObjectURL","click","removeChild","open","saveSvg","saveSvgAsPng"],"version":3,"file":"index.df6d75cd.js.map"}